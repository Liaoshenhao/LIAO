# 整型转换成字符串
## 1.sprintf()函数
```
-函数功能

把格式化的数据写入某个字符串缓冲区。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-头文件

stdio.h

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-函数原型

int sprintf( char *buffer, const char *format, [ argument] … );

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-参数列表

buffer：char型指针，指向将要写入的字符串的缓冲区。

format：格式化字符串。

[argument]...：可选参数，可以是任何类型的数据。

返回值：字符串长度（strlen）

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-参数说明及应用举例

sprintf格式的规格如下所示。[]中的部分是可选的。

%[指定参数][标识符][宽度][.精度]指示符

若想输出`%'本身时, 请使用`%%'处理。

1. 处理字符方向。负号时表示从后向前处理。

2. 填空字元。 0 的话表示空格填 0；空格是内定值，表示空格就放着。

3. 字符总宽度。为最小宽度。

4. 精确度。指在小数点后的浮点数位数。[3]

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-转换字符

%% 印出百分比符号，不转换。

%c 整数转成对应的 ASCII 字元。

%d 整数转成十进位。

%f 倍精确度数字转成浮点数。

%o 整数转成八进位。

%s 整数转成字符串。

%x 整数转成小写十六进位。

%X 整数转成大写十六进位。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-格式化数字字符串

如：

//把整数123 打印成一个字符串保存在s 中。

sprintf(s, "%d", 123); //产生"123"

可以指定宽度，不足的左边补空格：

sprintf(s, "%8d%8d", 123, 4567); //产生：" 123 4567"

当然也可以左对齐：

sprintf(s, "%-8d%8d", 123, 4567); //产生："123 4567"

也可以按照16 进制打印：

sprintf(s, "%8x", 4567); //小写16 进制，宽度占8 个位置，右对齐

sprintf(s, "%-8X", 4568); //大写16 进制，宽度占8 个位置，左对齐

这样，一个整数的16 进制字符串就很容易得到，但我们在打印16 进制内容时，通常想要一种左边补0 的等宽格式，那该怎么做呢？
很简单，在表示宽度的数字前面加个0 就可以了。

sprintf(s, "%08X", 4567); //产生："000011D7"

这里要注意一个符号扩展的问题：比如，假如我们想打印短整数（short）-1 的内存16 进制表示形式
在Win32 平台上，一个short 型占2 个字节，所以我们自然希望用4 个16 进制数字来打印它：

short si = -1;

sprintf(s, "%04X", si);

产生“FFFFFFFF”，怎么回事？因为spritnf 是个变参函数，除了前面两个参数之外，后面的参数都不是类型安全的
函数更没有办法仅仅通过一个“%X”就能得知当初函数调用前参数压栈时被压进来的到底是个4 字节的整数还是个2 字节的短整数
所以采取了统一4 字节的处理方式，导致参数压栈时做了符号扩展，扩展成了32 位的整数-1，打印时4 个位置不够了，就把32 位整数-1 的8 位16 进制都打印出来了。

如果你想看si 的本来面目，那么就应该让编译器做0 扩展而不是符号扩展（扩展时二进制左边补0 而不是补符号位）：

sprintf(s, "%04X", (unsigned short)si);

就可以了。或者：

unsigned short si = -1;

sprintf(s, "%04X", si);

sprintf 和printf 还可以按8 进制打印整数字符串，使用”%o”。注意8 进制和16 进制都不会打印出负数，都是无符号的，实际上也就是变量的内部编码的直接的16 进制或8 进制表示。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-控制浮点数打印格式

浮点数的打印和格式控制是sprintf 的又一大常用功能，浮点数使用格式符”%f”控制，默认保留小数点后6 位数字，比如：

sprintf(s, "%f", 3.1415926); //产生"3.141593"

但有时我们希望自己控制打印的宽度和小数位数，这时就应该使用：”%m /nf”格式，其中m 表示打印的宽度，n 表示小数点后的位数。比如：

sprintf(s, "%10.3f", 3.1415626); //产生：" 3.142"

sprintf(s, "%-10.3f", 3.1415626); //产生："3.142 "

sprintf(s, "%.3f", 3.1415626); //不指定总宽度，产生："3.142"

***注意一个问题****

int i = 100;

sprintf(s, "%.2f", i);

这是错误的，格式不正确，正确如下：

sprintf(s, "%.2f", (double)i);

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-连接字符串

sprintf 的格式控制串中既然可以插入各种东西，并最终把它们“连成一串”，自然也就能够连接字符串，从而在许多场合可以替代strcat
但sprintf 能够一次连接多个字符串（自然也可以同时在它们中间插入别的内容，总之非常灵活）。比如：

char* who = "I";

char* whom = "CSDN";

sprintf(s, "%s love %s.", who, whom); //产生："I love CSDN. "

strcat 只能连接字符串（一段以'\0'结尾的字符数组或叫做字符缓冲，null-terminated-string）
但有时我们有两段字符缓冲区，他们并不是以 ’’结尾。比如许多从第三方库函数中返回的字符数组，从硬件或者网络传输中读进来的字符流，它们未必每一段字符序列后面都有个相应的’’来结尾。
如果直接连接，不管是sprintf 还是strcat 肯定会导致非法内存操作，而strncat 也至少要求第一个参数是个null-terminated-string，那该怎么办呢？
我们自然会想起前面介绍打印整数和浮点数时可以指定宽度，字符串也一样的。比如：

char a1[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};

char a2[] = {'H', 'I', 'J', 'K', 'L', 'M', 'N'};

如果：

sprintf(s, "%s%s", a1, a2); //Don't do that!

或者：

sprintf(s, "%7s%7s", a1, a2);

都是有问题的，正确的应该是：

sprintf(s, "%.7s%.7s", a1, a2);//产生："ABCDEFGHIJKLMN"

这可以类比打印浮点数的”%m/nf”，在”%m.ns”中，m 表示占用宽度（字符串长度不足时补空格，超出了则按照实际宽度打印），n 才表示从相应的字符串中最多取用的字符数。自然，也可以前后都只取部分字符：

sprintf(s, "%.6s%.5s", a1, a2);//产生："ABCDEFHIJKL"

在许多时候，我们或许还希望这些格式控制符中用以指定长度信息的数字是动态的，而不是静态指定的
因为许多时候，程序要到运行时才会清楚到底需要取字符数组中的几个字符，这种动态的宽度/精度设置功能在sprintf 的实现中也被考虑到了
sprintf 采用”*”来占用一个本来需要一个指定宽度或精度的常数数字的位置，同样，而实际的宽度或精度就可以和其它被打印的变量一样被提供出来，于是，上面的例子可以变成：

sprintf(s, "%.*s%.*s", 7, a1, 7, a2);

或者：

sprintf(s, "%.*s%.*s", sizeof(a1), a1, sizeof(a2), a2);

实际上，前面介绍的打印字符、整数、浮点数等都可以动态指定那些常量值，比如：

sprintf(s, "%-*d", 4, 'A'); //产生"65 "

sprintf(s, "%#0*X", 8, 128); //产生"0X000080"，"#"产生0X

sprintf(s, "%*.*f", 10, 2, 3.1415926); //产生" 3.14"

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-利用sprintf 的返回值

较少有人注意printf/sprintf 函数的返回值，但有时它却是有用的，spritnf 返回了本次函数调用最终打印到字符缓冲区中的字符数目。也就是说每当一次sprinf 调用结束以后，你无须再调用一次strlen 便已经知道了结果字符串的长度。如：

int len = sprintf(s, "%d", i);

对于正整数来说，len 便等于整数i 的10 进制位数。

下面的是个完整的例子，产生10 个[0, 100)之间的随机数，并将他们打印到一个字符数组s 中，以逗号分隔开。

#include <stdio.h>

#include <stdlib.h>

#include <time.h>

int main() {

srand(time(0));

char s[64];

int offset = 0;

for(int i = 0; i < 10; i++) {

offset += sprintf(s + offset, "%d,", rand() % 100);

}

s[offset - 1] = '\n';//将最后一个逗号换成换行符。

printf(s);

return 0;

}

```

## 2. to_string()函数

```
-函数原型：
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-功能：
将数值转化为字符串。返回对应的字符串。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-头文件：
#include <string>

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-示例：
#include <iostream>   
#include <string>     
using namespace std;
 
int main ()
{
  string pi = "pi is " + std::to_string(3.1415926);
  string perfect = std::to_string(1+2+4+7+14) + " is a perfect number";
  cout << pi << '\n';
  cout << perfect << '\n';
  return 0;
}
结果：
pi is 3.141593
28 is a perfect number
```
## 3. itoa()函数

```
-函数原型：

toa():char *itoa( int value, char *string,int radix);

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-原型说明：

value：欲转换的数据。
string：目标字符串的地址。
radix：转换后的进制数，可以是10进制、16进制等，范围必须在 2-36。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-功能：
将整数value 转换成字符串存入string 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。

-返回值：
函数返回一个指向 str，无错误返回。

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-头文件

#include <stdlib.h>     ....C语言
#include <string.h>     ....C++

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-示例
#include<iostream>
#include<string>
using namespace std;
 
int main()
{
	int i=1024;
 
	char a[100]={0};
 
	for(int j=2;j<=36;j++)
	{
		itoa_s(i,a,j);
		cout<<a<<endl;
	}
	
	system("pause");
	return 0;
}


=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-特别说明

由于它不是标准C语言函数，所以不能在所有的编译器中使用。但是，大多数的编译器（如Windows上的）通常在头文件中包含这个函数。
```





